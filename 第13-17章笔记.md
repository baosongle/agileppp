# 第13-17章笔记

## Command 模式

Command 模式非常简单，只要在接口中定义了不带任何参数的方法，就是 Command 模式

```java
public interface Command {
  void do();
}
```

Java 中典型的 Command 模式有 `Runnable` 接口，我不知道 `Callable` 接口算不算，因为 `Callable` 接口会返回一个结果，而根据书上的例子 Command 是不返回任何东西的

在绝大多数情况下，方法的执行是需要外部参数的，而 Command 模式中定义的方法是不带参数的，因此本来需要传递给方法的参数，可能需要在构造实例的时候传递给构造函数、或者在构造之后通过 setter 方法注入。这样的方式的缺陷在于本来能够在一个方法内部就完成的事情，硬是提升到了类的层次。但是它的优势也很明显，参数的注入通常是使用工厂类完成的，因此实例的构造和方法的调用能够解耦

## Active Object 模式

Active Object 模式我并没有看懂，根据网上查来的信息，这种模式似乎是提供了一个任务执行器，调用方把 `Command` 实例传入执行器后，由执行器决定在哪个时间、哪个线程执行命令，这就实现了调用和执行的解耦。

Java 中的 `Executors` 系列框架提供了 Active Object 模式的实现

## Template 模式与 Strategy 模式

在写代码过程中，我们经常被要求实现一些功能，这些功能可以从宏观角度找到共同点，但是在某些细节上存在着些许不同，于是可以将这些不同的地方抽象出来独立成一个方法，宏观上的共同点也会独立成方法，由框架作者来实现。通常 Template 模式会定义一个抽象类，有使用者来继承并实现其中的抽象方法；而 Strategy 模式定义一个接口，由使用者来实现。Template 模式把宏观共同点独立出来的方法放在抽象类中，这个方法会负责调用其他抽象方法，以实现业务逻辑。而 Strategy 会将相似的方法移动到一个新类中。Strategy 模式遵循了 DIP 原则

## Facade 模式与 Mediator 模式

这两种模式平常用的太多，已经司空见惯了

## Singleton 模式

Singleton 模式平常用的也很多，使用它通常因为这种类的实例并不保存任何数据，因此只需要创建一个实例也就足够了

另外，书上创建 Singleton 实例的代码是错误的

## Monostate 模式

这种模式我很少见到，它把一些实例需要使用的变量定义成静态变量，使得所有实例都能访问同一份数据。我之前写过一个统计缓存的命中率的代码，就是使用了这个模式来保存缓存的命中次数。使用这个模式需要特别关注静态变量的线程安全问题

## Null Object 模式

Null Object 模式也用的比较多，他的好处是调用方不用对一个方法返回的结果进行任何判断，直接使用即可。举个例子，在做数据库查询时，如果我们的查询的结果是多个变量，我们会使用一个 `List` 保存结果，如果某次查询中我们没有得到任何数据，那么这个方法应当返回 `null` 还是 `Collections.emptyList()` 呢？返回 `null` 很好理解，因为数据库没有任何匹配的数据，但是这样，调用方可能在使用结果前需要先对结果进行判空，才能执行遍历。而返回一个空 `List` 调用者就不需要判空了，可以直接遍历，因为对空的 `List` 做遍历也是跟什么事都没做一样。另外一个例子是，对于上面的 `Command` 接口，我们可以定义一个 `NullCommand` 实现，在其中的 `do` 方法中不做任何事，这就是 Null Object 模式。

---

