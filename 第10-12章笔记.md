# 第 10-12 章笔记

第 10 章的内容是**里式替换原则（LSP）**，定义如下

> 子类必须能够替换掉它的基类型

在 Java 中，当你使用了 `instanceof` 关键字的时候，就需要仔细想想自己是不是违背了里式替换原则，以及你的基类或是接口的设计是不是合理的

书中举了一个例子，我们在几何学中经常遇到长方形 `Rectangle` 和正方形 `Square` 。维基百科上对于长方形的定义是有一个角是直角的平行四边形，对于正方形的定义是四边相等长方形。从这里看出，正方形**是一个**特殊的长方形

但是从行为方式的角度看，正方形**并不是**长方形。因为对于长方形，我们隐含了一个条件：长方形的长和宽是可以独立变化的。而正方形并不满足这个条件：正方形的长和宽永远都是共同变化的。作者由此引入了 Bertrand Meyer 的**基于契约设计（Design By Contract）** 

> 在子类型中，只能使用相等或更弱的前置条件替换基类型的前置条件，只能使用相等或更强的后置条件替换基类型的后置条件

但是什么是前置条件和后置条件呢？前置条件我们可以为是方法的输入参数必须满足的条件，方法的调用者必须保证传入的参数满足前置条件，否则方法的输出结果可能是不确定的。比如说 Java 中的 `List` 接口定义了一个 `get` 方法来取出某列表中的一个元素，参考文档我们可以看到这个方法的前置条件是传入的索引必须是大于等于 0、小于数组长度的整数，否则会抛出  `IndexOutOfBoundsException` 。如果说你使用过 Python 你会知道 Python 中相似的方法是可以传入索引 -1 的，索引 -1 会让方法会返回数组中最后一个元素。你可以效仿 Python，自己创建一个 `List` 的实现类 `NegativeableIndexList`，允许调用者传入负数的索引，让 `get` 方法倒序返回列表中的元素。这样的话，`NegativeableIndexList.get(int i)` 的前置条件**更弱了**，因为基类型 `List.get(int i)` 的前置条件是

1. 索引 `i` 必须是整数
2. `i >= 0`
3. `i < size()`

而 `NegativeableIndexList.get(int i)` 去掉了第二个条件，因此条件更弱了。在代码中，你可以把所有的 `List<SomeObject> = new LinkedList<>()` 改成 `List<SomeObject> = new NegativeableIndexList<>()`，程序依然能够编译通过，且如果原先的代码在运行时不抛出异常，那么新的代码也不会抛出异常，因为新代码需要的传入参数要满足的条件放宽了

而后置条件就是方法的输出行为。在 `Rectangle` 和 `Square` 的例子中，`Square` 的 `setWidth` 和 `setHeight` 的前置条件没有变化（都要求输入的参数 >= 0），但是后置条件变化了。 `Rectangle` 的 `setWidth` 的后置条件是

1. `Rectangle.getWidth == newWidth`
2. `Rectangle.getHeight == oldHeight`

即长和宽能够独立变化。而 `Square.setWidth` 并不满足第二个条件，因此 `Square.setWidth` 的后置条件减弱了，这就违反了基于契约设计的理念，因此让 `Square` 继承于 `Rectangle` 是不合理的

---

第 11 章讲述了**依赖倒置原则（DIP）**，定义如下

1. 高层模块不应依赖于低层模块，二者都应依赖于抽象
2. 抽象不应依赖于细节，细节应该依赖于抽象

按照我的理解，DIP 要求我们做到面向接口编程。一个常见的例子是我们的 JavaWeb 项目中的 DAO 层和 Service 层。DAO 层通常是负责与数据库连接的代码，比如 MyBatis 和 JPA ；Service 层通常定义一些接口，接口内有 `save` 、`update` 等方法。Service 层依赖于 DAO 层，更上层的代码依赖于 Service 层的接口而不能依赖于 DAO 层，这样当我们想把 DAO 层的框架从 MyBatis 替换为 JPA、或者把 DBMS 从 Oracle 替换为 MySQL 的时候，业务层的代码实际上是不会变化的，变化的仅仅是 DAO 层，这样我们就把变化局限到了更小的范围内，使得代码的改动更加容易

---

第 12 章讲述了**接口隔离原则（ISP）**，这个原则要求我们定义接口中的方法尽量的少，做到只定义与接口的作用有意义的方法，不要加入无关的方法，否则会让接口成为胖接口

书中的例子是我们需要有一个具有报警功能的门，门在保持开启状态超过一定时间后就必须发出警报。警报功能由 `Timer` 和 `TimerClient` 来实现，基类 `Door` 是不能定义与 `Timer` 和 `TimerClient` 相关的任何方法的，因为这样当其他类型的门想继承 `Door` 时，就会拥有完全没有用的 `Timer` 和 `TimerClient` 代码，这种情况下 `Door` 就变成了胖接口。正确的方法是把 `Timer` 和 `TimerClient` 相关代码定义在 `Door` 的一个子类 `TimedDoor` 中，其他类型的门则继承 `Door` ，不会与 `Timer` 发生任何瓜葛